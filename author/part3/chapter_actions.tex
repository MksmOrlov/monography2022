\chapter{Формализация понятий действия, задачи, метода, средства, навыка и технологии}
\chapauthortoc{Шункевич Д.В.\\Ковалёв М.В.\\Никифоров С.А.}
\label{chapter_actions}

\vspace{-7\baselineskip}

\begin{SCn}
	\begin{scnrelfromlist}{автор}
		\scnitem{Шункевич Д.В.}
		\scnitem{Ковалёв М.В.}
		\scnitem{Никифоров C.F.}
	\end{scnrelfromlist}

	\bigskip

	\scntext{аннотация}{В главе уточнена формальная трактовка таких понятий, как действие, задача, класс действий, класс задач, метод, навык, что в совокупности позволило определить на их основе понятие модели решения задач.}

	\bigskip

	\begin{scnrelfromlist}{подраздел}
		\scnitem{\ref{sec_action_concept}\nameref{sec_action_concept}}
		\scnitem{\ref{sec_problem_concept}\nameref{sec_problem_concept}}
		\scnitem{\ref{sec_3}~Субъектно-объектные спецификации воздействий и действий}
		\scnitem{\ref{sec_4}~Формализация понятий сложного действия, класса задач и метода}
		\scnitem{\ref{sec_5}~Формализация понятий навыка, класса методов и модели решения задач}
		\scnitem{\ref{sec_6}~Формализация понятий деятельности, вида деятельности и технологии}
	\end{scnrelfromlist}

	\bigskip

	\begin{scnrelfromlist}{ключевое понятие}
		\scnitem{воздействие}
		\scnitem{действие}
		\scnitem{задача}
		\scnitem{класс действий}
		\scnitem{класс задач}
		\scnitem{метод}
		\scnitem{язык представления методов}
		\scnitem{модель решения задач}
		\scnitem{навык}
		\scnitem{деятельность}
		\scnitem{вид деятельности}
		\scnitem{технология}
	\end{scnrelfromlist}

	\bigskip

	\begin{scnrelfromlist}{библиографическая ссылка}
		\scnitem{\scncite{Standard2021}}
		\scnitem{\scncite{Tuzov1986}}
		\scnitem{\scncite{Martynov1984}}
		\scnitem{\scncite{Ikeda1998}}
		\scnitem{\scncite{Studer1996}}
		\scnitem{\scncite{Benjamins1999}}
		\scnitem{\scncite{Chandrasekaran1999}}
		\scnitem{\scncite{Fensel1998Reuse}}
		\scnitem{\scncite{Kemke2001}}
		\scnitem{\scncite{Tu1995}}
		\scnitem{\scncite{Trypuz2007}}
		\scnitem{\scncite{Fang2019}}
		\scnitem{\scncite{McBride2021}}
		\scnitem{\scncite{Crowther2020}}
		\scnitem{\scncite{McCann1998}}
		\scnitem{\scncite{Yan2014}}
		\scnitem{\scncite{Crubezy2004}}
	\end{scnrelfromlist}

\end{SCn}

\section*{Введение в Главу \ref{chapter_actions}}
Возможности решателя задач интеллектуальной системы в значительной степени определяются качеством ее базы знаний. Другими словами, при разработке решателей задач необходимо описывать не только \textit{операционную семантику} решателя, то есть семейство интерпретаторов соответствующих моделей решения задач, но и \textit{декларативную семантику} модели решения задач, то есть собственно тексты программ (не программ низкоуровневых агентов, а программ более высокого уровня, интерпретируемых соответствующим набором агентов), логические утверждения, конкретные конфигурации искусственных нейронных сетей и т.д.

В рамках данной главы формально уточняются в рамках соответствующего набора онтологий такие понятия, как \textit{действие}, \textit{задача}, \textit{модель решения задач}, \textit{метод}, \textit{навык} и другие, на основе которых в \textit{Главе \ref{chapter_situation_management} \nameref{chapter_situation_management}} уточняется собственно модель гибридного \textit{решателя задач ostis-системы}.

%TODO Уточнить, будет ли где-то ранее говориться про sc-агенты и многоагентный подход
Разработка указанного семейства онтологий позволяет:
\begin{textitemize}
	\item явно связать \textit{класс задач} и способ (метод) решения задач данного класса;
	\item это, в свою очередь, позволит накапливать более сложные компоненты решателей задач и еще больше упростить их интеграцию, поскольку вместе с коллективом sc-агентов в соответствующий компонент также будут входить необходимые фрагменты базы знаний, априори согласованные с указанным коллективом sc-агентов;
	\item это, в свою очередь, позволит сделать средства автоматизации разработки решателей задач более интеллектуальными, в частности, позволит автоматизировать процесс подбора компонентов решателя на основе спецификации классов задач, которые должна уметь решать проектируемая интеллектуальная система;
	\item в дальнейшем это позволит интеллектуальной системе самостоятельно обращаться в библиотеку компонентов решателей задач (см. \ref{ps_components_section}~\nameref{ps_components_section}) и подбирать компоненты, исходя из новых классов задач, с которыми столкнулась система, то есть позволит интеллектуальной системе самостоятельно изучать новые \textit{навыки};
	\item с другой стороны, такой подход позволит интеллектуальной системе самостоятельно подобрать комбинацию моделей решения задач для решения задач определенного класса (точнее говоря, поскольку в основу решателя положен многоагентный подход, то коллектив sc-агентов, интерпретирующих различные модели решения задач, сможет лучше определить, какие именно из sc-агентов и в каком порядке должны работать при решении конкретной комплексной задачи).
\end{textitemize}


\section{Формализация понятия действия}
\label{sec_action_concept}

\begin{SCn}
	\begin{scnrelfromlist}{ключевое понятие}
		\scnitem{воздействие}
		\scnitem{действие}
		\scnitem{информационное действие}
		\scnitem{поведенческое действие}
		\scnitem{эффекторное действие}
		\scnitem{рецепторное действие}
		\scnitem{элементарное действие}
		\scnitem{сложное действие}
	\end{scnrelfromlist}

	\begin{scnrelfromlist}{ключевое отношение}
		\scnitem{субъект\scnrolesign}
		\scnitem{объект\scnrolesign}
		\scnitem{цель*}
	\end{scnrelfromlist}
\end{SCn}

Прежде чем говорить о моделях решения задач и решателя задач, необходимо формально уточнить понятие задачи и понятие действия, направленного на решение той или иной задачи или ее подзадач.

В рамках \textit{Технологии OSTIS} задачу будем трактовать как формальную спецификацию некоторого действия, поэтому целесообразно вначале уточнить понятие \textbf{\textit{действия}}, которое определяется через понятие \textbf{\textit{воздействия}}. Рассмотрим спецификацию понятия \textit{воздействие} в SCn-коде.

\begin{SCn}
	\scnheader{воздействие}
	\scnidtf{\textit{процесс} воздействия одной сущности (или некоторого множества \textit{сущностей}) на другую \textit{сущность} (или на некоторое множество других \textit{сущностей})}
	\scnidtf{\textit{процесс}, в котором могут быть явно выделены хотя бы одна воздействующая сущность (\textit{субъект\scnrolesign}) и хотя бы одна \textit{сущность}, на которую осуществляется воздействие (\textit{объект\scnrolesign})}
	\scnidtf{акция}
	\scnsubset{процесс}
	\begin{scnindent}
		\scnidtf{динамическая структура}
	\end{scnindent}

	\scnheader{субъект\scnrolesign}
	\scnidtf{воздействующая сущность\scnrolesign}
	\scnidtf{сущность, создающая \textit{причину} изменений другой сущности (объекта)\scnrolesign}

	\scnheader{объект\scnrolesign}
	\scnidtf{воздействуемая сущность\scnrolesign}
	\scnidtf{сущность, являющаяся в рамках заданного воздействия исходным условием (аргументом), необходимым для выполнения этого воздействия\scnrolesign}
\end{SCn}

Каждому \textit{воздействию} может быть поставлен в соответствие (1) некоторый \textit{субъект\scnrolesign}, т.е. сущность, осуществляющая \textit{воздействие} (в частности, это может быть некоторое физическое поле), и (2) некоторый \textit{объект\scnrolesign}, т.е. сущность, на которую воздействие направлено. Если \textit{воздействие} связано с \textit{материальной сущностью}, то его объектом является либо сама эта \textit{материальная сущность}, либо некоторая ее пространственная часть.

Поскольку \textit{воздействия} являются частным видом \textit{процессов}, воздействиями наследуются все свойства \textit{процессов}. В частности, используются все \textit{параметры}, заданные на множестве \textit{процессов}, например, \textit{длительность*}, \textit{момент начала процесса*}, \textit{момент завершения процесса\scnsupergroupsign}. Подробнее эти отношения описываются в \textit{Главе \ref{chapter_top_ontologies} \nameref{chapter_top_ontologies}}.

Так же, так как воздействие является процессом и, соответственно, представляет собой \textit{динамическую структуру}, то и знак \textit{субъекта воздействия\scnrolesign}, и знак \textit{объекта воздействия\scnrolesign} являются элементами данной структуры. В связи с этим можно рассматривать отношения \textit{субъект воздействия\scnrolesign} и \textit{объект воздействия\scnrolesign} как \textit{ролевые отношения}. Данный факт не запрещает вводить аналогичные \textit{неролевые отношения}, однако это нецелесообразно.

Рассмотрим спецификацию понятия \textit{действие} в SCn-коде.
\begin{SCn}
	\scnheader{действие}
	\scnidtf{\textit{воздействие}, в котором \textit{субъект\scnrolesign} осуществляет \textit{воздействие} целенаправленно, т.е. в соответствии с некоторой \textit{целью*}}
	\scnidtf{целенаправленное воздействие, выполняемое одним или несколькими субъектами (кибернетическими системами) с возможным применением некоторых инструментов}
	\scnidtf{акт}
	\scnidtf{операция}
	\scnidtf{осознанное воздействие}
	\scnidtf{активное воздействие}
	\scnsubset{воздействие}
	\begin{scnindent}
		\scnidtf{процесс, в котором могут быть явно выделены хотя бы одна воздействующая сущность (субъект воздействия') и хотя бы одна сущность, на которую осуществляется воздействие (объект воздействия')}
		\scnsubset{процесс}
	\end{scnindent}

	\scnidtf{целенаправленный ("осознанный"{}) процесс, выполняемый (управляемый, реализуемый) неким субъектом}
	\scnidtf{работа}
	\scnidtf{процесс решения некоторой задачи}
	\scnidtf{процесс достижения некоторой цели}
	\scnidtf{целостный фрагмент некоторой деятельности}
	\scnidtf{целенаправленный процесс, управляемый некоторым субъектом}
	\scnidtf{процесс выполнения некоторого действия некоторым субъектом (исполнителем) над некоторыми объектами}
%
%	\scnsuperset{элементарное действие}
%	\begin{scnindent}
%		\scnidtf{действие, выполнение которого не требует его декомпозиции на множество поддействий (частных действий, действий более низкого уровня)}
%		\scnexplanation{Элементарное действие выполняется одним индивидуальным субъектом и является либо элементарным действием, выполняемым в памяти этого субъекта (элементарным действием его "процессора"{}), либо элементарным действием одного из его эффекторов.}
%	\end{scnindent}
%	\scnsuperset{сложное действие}
%	\begin{scnsubdividing}
%		\scnitem{действие, выполняемое кибернетической системой в собственной памяти}
%		\scnitem{действие, выполняемое кибернетической системой в своей внешней среде}
%		\scnitem{действие, выполняемое кибернетической системой над своей физической оболочкой}
%	\end{scnsubdividing}

	\scnheader{цель*}
	\scnidtf{целевая ситуация*}
	\scnsubset{спецификация*}
	\scnidtf{описание того, что требуется получить (какая ситуация должна быть достигнута) в результате выполнения заданного (специфицируемого) действия*}
\end{SCn}

Каждое \textit{действие}, выполняемое тем или иным \textit{субъектом}, трактуется как процесс решения некоторой задачи, т.е. процесс достижения заданной \textit{цели*} в заданных условиях, и, следовательно, выполняется целеноправленно. При этом явное указание \textit{действия} и его связи с конкретной задачей может не всегда присутствовать в памяти. Некоторые \textit{задачи} могут решаться определенными субъектами перманентно, например, оптимизация \textit{базы знаний}, поиск некорректностей и т.д. и для подобных задач не всегда есть необходимость явно вводить \textit{структуру}, являющуюся формулировкой \textit{задачи}.

Каждое \textit{действие} может обозначать сколь угодно малое преобразование, осуществляемое во внешней среде либо в памяти некоторой \textit{кибернетической системы}, однако в памяти явно вводятся знаки только тех \textit{действий}, для которых есть небходимость явно хранить в памяти их спецификацию в течение некоторого времени.

%TODO подумать, нужно ли в этом параграфе
При выполнении \textit{действия} можно выделить этапы:
\begin{scnitemize}
	\item{построение \textit{плана действия}, декомпозиция (детализация) действия в виде системы его \textit{поддействий};}
	\item{выполнение построенного плана \textit{действия}}
\end{scnitemize}

Класс действий имеет разбиение по следующим признакам:
\begin{scnitemize}
	\item{место выполнения действия;}
	\item{функциональная сложность действия;}
	\item{многоагентность выполнения действия;}
	\item{текущее состояние действия;}
\end{scnitemize}

Далее рассмотрим разбиение по каждому признаку.

\begin{SCn}
	\scnheader{действие}
	\scnrelfrom{разбиение}{Типология классов действий по признаку места выполнения действия}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnitem{действие, выполняемое в памяти субъекта действия}
			\begin{scnindent}
				\scnidtf{информационное действие}
				\scnidtf{действие, выполняемое в памяти}
				\scnidtf{действие кибернетической системы, направленное на обработку информации, хранимой в её памяти}
			\end{scnindent}
			\scnitem{действие, выполняемое во внешней среде субъекта действия}
			\begin{scnindent}
				\scnidtf{поведенчиское действие}
			\end{scnindent}
			\scnitem{рецепторное действие}
			\begin{scnindent}
				\scnidtf{сенсорное действие}
			\end{scnindent}
			\scnitem{эффекторное действие}
		\end{scneqtoset}
	\end{scnindent}
\end{SCn}

Результатом выполнения \textbf{\textit{действия, выполняемого в памяти субъекта действия}} в общем случае является некоторое новой состояние памяти информационной системы (не обязательно \textit{sc-памяти}), достигнутое исключительно путем преобразования информации, хранящейся в памяти системы, то есть либо посредством генерации новых знаний на основе уже имеющихся, либо посредством удаления знаний, по каким-либо причинам ставших ненужными. Следует отметить, что если речь идет об изменении состояния \textit{sc-памяти}, то любое преобразование информации можно свести к ряду элементарных действий по генерации, удалению или изменению инцидентности \textit{sc-элементов} относительно друг друга.

В случае \textbf{\textit{действия, выполняемого во внешней среде субъекта действия}} результатом его выполнения будет новое состояние внешней среды. Очень важно отметить, что под внешней средой в данном случае понимаются также и компоненты системы, внешние с точки зрения памяти, то есть не являющиеся хранимыми в ней информационными конструкциями. К таким компонентам можно отнести, например, различные манипуляторы и прочие средства воздействия системы на внешний мир, то есть к поведенческим задачам можно отнести изменение состояния механической конечности робота или непосредственно вывод некоторой информации на экран для восприятия пользователем.

Каждое \textbf{\textit{рецепторное действие}} обозначает класс \textit{действий}, которые осуществляют преобразования в памяти субъекта действия под воздействием внешней среды.

Соответственно, каждое \textbf{\textit{эффекторное действие}} обозначает класс \textit{действий}, которые осуществляют преобразования внешней среды под воздействием памяти субъекта воздействия.

Так же действия могут разбиваться по признакой их функциональной сложности.
\begin{SCn}
	\scnheader{действие}
	\scnrelfrom{разбиение}{Типология классов действий по признаку функциональной сложности действия}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnitem{атомарное действие}
			\begin{scnindent}
				\scnidtf{элементарное действие}
			\end{scnindent}
			\scnitem{неатомарное действие}
			\begin{scnindent}
				\scnidtf{неэлементарное действие}
				\scnidtf{сложное действие}
				\begin{scnrelfromset}{покрытие}
					\scnitem{легко выполнимое неатомарное действие}
					\scnitem{трудно выполнимое сложное действие}
					\begin{scnindent}
						\scnidtf{интеллектуальное действие}
					\end{scnindent}
				\end{scnrelfromset}
			\end{scnindent}
		\end{scneqtoset}
	\end{scnindent}
\end{SCn}

Разберем подробнее каждый элемент приведенной иерархии.
\textbf{\textit{Атомарное действие}}  выполняется одним индивидуальным субъектом и не включает в себя выполнение каких-либо дочерних действий.

Соответственно, \textbf{\textit{неатомарное действие}} является действием, выполнение которого требует декомпозиции этого действия на множество его \uline{поддействий}, т.е. частных действий более низкого уровня. Более частные действия могут выполняться как последовательно, так и параллельно.

Декомпозиция неатомарного действия на поддействия может иметь весьма сложный иерархический вид с большим числом уровней иерархии, т.е. поддействиями \textit{неатомарного действия} могут также \textit{неатомарные действия}. Уровень сложности действия можно определять (1) общим числом его поддействий и (2) числом уровней иерархии этих поддействий. Примером может служить запись одной и той же процедурной программы на языке программирования более высокого уровня и на языке программирования более низкого уровня. В данном случае атомарность действий строго определяется на уровне языка.

Темпоральные соотношения между \textit{поддействиями} неатомарного \textit{действия} могут быть самые различные, но в пройстейшем случае \textit{неатомарное действие} представляет собой строгую последовательность \textit{действий} более низкого уровня иерархии.

В состав \textit{неатомарного действия} могут входить не только \textit{собственно поддействия} этого \textit{неатомарного действия}, но также и специальные \textit{поддействия}, осуществляющие \uline{управление} процессом выполнения \textit{неатомарного действия}, и, в частности, \textit{поддействия}, осуществляющие инициирование поддействий, передачу управления \textit{поддействиям}.

Действие можно назвать \textbf{\textit{легко выполнимым неатомарным действием}} в случае, когда для выполнения этого действия известен соответствующий \textit{метод} и соответствующие этому методу исходные данные, а также (для действий, выполняемых во внешней среде) имеются в наличии все необходимые исходные объекты (расходные материалы и комплектация), а также средства (инструменты)

В свою очередь, \textbf{\textit{трудно выполнимым неатомарным действием}} действие является тогда, когда для его выполнения в текущий момент либо неизвестен соответствующий \textit{метод}, либо возможные \textit{методы} известны, но отсутствуют условия их применения. Это действие декомпозируется на несколько самостоятельных поддействий, каждое из которых выявляет (локализует) противоречия (ошибки) конкретного формализуемого вида, для которого в базе знаний существует точное определение.

Признак многоагентности выполнения действия характеризует количество субъектов, выполнеяющих действие.
\begin{SCn}
	\scnheader{действие}
	\scnrelfrom{разбиение}{Типология классов действий по признаку многоагентности выполнения действия}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnitem{индивидуальное действие}
			\begin{scnindent}
				\scnidtf{действие, выполняемое одним субъектом (агентом)}
				\scnidtf{действие, выполняемое индивидуальной кибернетической системой}
			\end{scnindent}
			\scnitem{коллективное действие}
			\begin{scnindent}
				\scnidtf{действие, выполняемое коллективом субъектов (многоагентной системой)}
				\scnidtf{действие, выполняемое коллективом кибернетических систем (коллективом субъектов)}
				\scnsuperset{действие, выполняемое коллективом людей}
				\scnsuperset{действие, выполняемое коллективом индивидуальных компьютерных систем}
				\scnsuperset{действие, выполняемое коллективом людей и индивидуальных компьютерных систем}
				\begin{scnindent}
					\scnsuperset{действие, выполняемое Экосистемой OSTIS}
					\scnsuperset{действие, выполняемое одним человеком во взаимодействии с одной индивидуальной компьютерной системой}
				\end{scnindent}
			\end{scnindent}
		\end{scneqtoset}
	\end{scnindent}
\end{SCn}


Последним признаком разбиения классов действия является признак текущего состояния действия.
\begin{SCn}
	\scnheader{действие}
	\scnrelfrom{разбиение}{Типология классов действий по признаку текущего состояния действия}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnitem{планируемое действие}
			\begin{scnindent}
				\scnidtf{запланированное, но не инициированное действие}
				\scnidtf{будущее действие}
			\end{scnindent}
			\scnitem{инициированное действие}
			\begin{scnindent}
				\scnidtf{действие, ожидающее начала своего выполнения}
				\scnidtf{действие, подлежащее выполнению}
			\end{scnindent}
			\scnitem{выполняемое действие}
			\begin{scnindent}
				\scnidtf{активное действие}
				\scnidtf{действие, выполняемое в текущий момент}
				\scnidtf{настоящее действие}
			\end{scnindent}
			\scnitem{прерванное действие}
			\begin{scnindent}
				\scnidtf{действие, ожидающее продолжения своего выполнения}
				\scnidtf{отложенное действие}
			\end{scnindent}
			\scnitem{выполненное действие}
			\begin{scnindent}
				\scnidtf{завершенное действие}
				\scnidtf{прошлое действие}
				\begin{scnsubdividing}
					\scnitem{успешно выполненное действие}
					\scnitem{безуспешно выполненное действие}
					\begin{scnindent}
						\scnsuperset{действие, выполненное с ошибкой}
					\end{scnindent}
				\end{scnsubdividing}
			\end{scnindent}
			\scnitem{отмененное действие}
		\end{scneqtoset}
	\end{scnindent}
\end{SCn}

Во множество \textbf{\textit{планируемых действий}} входят \textit{действия}, начало выполнение которых запланировано на какой-либо момент в будущем(\textit{начало*}).

Во множество \textbf{\textit{инициированных действий}} входят \textit{действия}, выполнение которых инициировано в результате какого-либо события.
В общем случае, \textit{действия} могут быть инициированы по следующим причинам:
\begin{scnitemize}
	\item явно путем проведения соответствующей \textit{sc-дуги  принадлежности} каким-либо \textit{субъектом (заказчиком*)}. В случае действия в \textit{sc-памяти}, оно может быть инициировано как внутренним \textit{sc-агентом} системы, так и пользователем при помощи соответствующего пользовательского интерфейса. При этом, спецификация действия может быть сформирована одним \textit{sc-агентом}, а собственно добавление во множество \textit{инициированных действий} может быть осуществлено позже другим \textit{sc-агентом};
	\item в результате того, что одно или несколько \textit{действий}, предшествовавших данному в рамках некоторой декомпозиции, стали \textit{прошлыми сущностями} (процедурный подход);
	\item в результате того, что в \textit{памяти} системы появилась конструкция, соответствующая некоторому условию инициирования \textit{sc-агента}, который должен выполнить данное \textit{действие} (декларативный подход).
\end{scnitemize}

Следует отметить, что декларативный и процедурный подходы можно рассматривать как две крайности, использование только одной из которых не является удобным и целесообразным. При этом, например, принципы инициирования по процедурному подходу могут быть полностью сведены к набору декларативных условий инициирования, но как было сказано, это не всегда удобно и наиболее рациональным будет комбинировать оба подхода в зависимости от ситуации.

По сути, попадание некоторого \textit{действия} во множество \textit{инициированных действий} говорит о том, что, по мнению некоторого \textit{субъекта} (заказчика, инициатора), оно готово к выполнению и должно быть выполнено, то есть спецификация данного \textit{действия} по мнению данного \textit{субъекта} сформирована в степени, достаточной для решения поставленной \textit{задачи} и существует некоторый другой \textit{субъект} (исполнитель), который может приступать к выполнению \textit{действия}. Однако стоит отметить, что с точки зрения \textit{исполнителя} такая спецификация \textit{действия} в общем случае может оказаться недостаточной или некорректной.

Во множество \textbf{\textit{выполняемых действий}} входят \textit{действия}, к выполнению которых приступил какой-либо из соответствующих \textit{субъектов}.
Попадание \textit{действия} в данное множество говорит о следующем:
\begin{scnitemize}
	\item рассматриваемое \textit{действие} уже попало во множество \textit{инициированных действий};
	\item существует как минимум один \textit{субъект}, условие инициирования которого соответствует спецификации данного \textit{действия}.
\end{scnitemize}

После того, как собственно процесс выполнения завершился, \textit{действие} должно быть удалено из множества \textit{выполняемых действий} и добавлено во множество \textit{выполненных действий} или какое-либо из его подмножеств.

Понятие \textit{выполняемое действие} является неосновным, и вместо того, чтобы относить конкретные действия к данному классу, их относят к классу \textit{настоящих сущностей}.

Во множество \textbf{\textit{прерванных действий}} входят \textit{действия}, которые уже были инициированы, однако их выполнение невозможно по каким-либо причинам, например в случае, когда у исполнителя в данный момент есть более приоритетные задачи

Во множество \textbf{\textit{выполненных действий}} попадают \textit{действия}, выполнение которых завершено с \uline{точки зрения \textit{субъекта}}, осуществлявшего их выполнение. Таким образом, понятие \textit{выполненного действия} является относительным, поскольку с точки зрения разных субъектов одно и то же действие может считаться выполненным или все еще выполняющимся.

В зависимости от результатов конкретного процесса выполнения, рассматриваемое \textit{действие} может стать элементом одного из подмножеств множества \textit{выполненных действий}.

Понятие \textit{выполненное действие} является неосновным, и вместо того, чтобы относить конкретные \textit{действия} к данному классу, их относят к классу \textit{прошлых сущностей}.

Во множество \textbf{\textit{успешно выполненных действий}} попадают \textit{действия}, выполнение которых успешно завершено с точки зрения \textit{субъекта}, осуществлявшего их выполнение, т.е. достигнута поставленная цель, например, получены решение и ответ какой-либо задачи, успешно преобразована какая-либо конструкция и т.д. Очень важно отметить, что в общем случае выделить критерии успешности или безуспешности выполнения действий того или иного класса \uline{невозможно}, поскольку эти критерии, во-первых, зависят от контекста, во-вторых, могут быть разными с точки зрения разных субъектов. Однозначно критерии успешности выполнения действий могут быть сформулированы для некоторых частных классов действий, например, классов операторов некоторого процедурного языка программирования (например, \textit{scp-операторов}). Таким образом, понятие \textit{успешно выполненное действие} является относительным.

Если действие было выполнено успешно, то, в случае действия по генерации каких-либо знаний, к \textit{действию} при помощи связки отношения \textit{результат*} приписывается \textit{sc-конструкция}, описывающая результат выполнения указанного действия. В случае, когда действие направлено на какие-либо изменения базы знаний, \textit{sc-конструкция}, описывающая результат действия, формируется в соответствии с правилами описания истории изменений базы знаний.

В случае, когда успешное выполнение \textit{действия} приводит к изменению какой-либо конструкции в \textit{sc-памяти}, которое необходимо занести в историю изменений базы знаний или использовать для демонстрации протокола решения задачи, то генерируется соответствующая связка отношения \textit{результат*}, связывающая задачу и \textit{sc-конструкцию}, описывающую данное изменение.

Во множество \textbf{\textit{безуспешно выполненных действий}} попадают \textit{действия}, выполнение которых не было успешно завершено с точки зрения \textit{субъекта}, осуществлявшего их выполнение, по каким-либо причинам.

Можно выделить две основные причины, по которым может сложиться указанная ситуация:
\begin{scnitemize}
	\item соответствующая \textit{задача} сформулирована некорректно;
	\item формулировка соответствующей \textit{задачи} корректна и понятна системе, однако решение данной задачи в текущий момент не может быть получено за удовлетворительное с точки зрения заказчика или исполнителя сроки.
\end{scnitemize}

Для конкретизации факта некорректности формулировки задачи можно выделить ряд более частных классов \textit{безуспешно выполненных действий}, например:
\begin{scnitemize}
	\item \textit{действие, спецификация которого противоречит другим знаниям системы} (например, не выполняется неравенство треугольника);
	\item \textit{действие, при спецификации которого использованы понятия, неизвестные системе};
	\item \textit{действие, выполнение которого невозможно из-за недостаточности данных} (например, найти площадь треугольника по двум сторонам);
	\item и другие.
\end{scnitemize}

Для конкретизации факта безуспешности выполнения некоторого действия в системе могут также использоваться дополнительные подмножества данного множества, при необходимости снабженные естественно-языковыми или формальными комментариями.

Во множество \textbf{\textit{действий, выполненных с ошибкой}}, попадают \textit{действия}, выполнение которых не было успешно завершено с точки зрения \textit{субъекта}, осуществлявшего их выполнение, по причине возникновения какой-либо ошибки, например, некорректности спецификации данного \textit{действия} или нарушения её целостности каким-либо \textit{субъектом} (в случае \textit{действия в sc-памяти}).


\section{Формализация понятия задачи}
\label{sec_problem_concept}

\begin{SCn}
	\begin{scnrelfromlist}{ключевое понятие}
		\scnitem{задача}
	\end{scnrelfromlist}

	\begin{scnrelfromlist}{ключевое отношение}
		\scnitem{субъект\scnrolesign}
		\scnitem{объект\scnrolesign}
		\scnitem{цель*}
	\end{scnrelfromlist}
\end{SCn}

В свою очередь, \textit{задачу} будем трактовать как спецификацию некоторого действия, в рамках которой, в зависимости от ситуации, при помощи перечисленных выше отношений может быть заранее указан контекст выполнения действия, способ его выполнения, исполнитель, заказчик, планируемый результат и т.д.

Рассмотрим спецификацию понятия \textit{задача} в SCn-коде.

\begin{SCn}
	\scnheader{задача}
	\scnidtf{описание некоторого желаемого состояния или события либо в базе знаний, либо во внешней среде}
	\scnidtf{формулировка задачи}
	\scnidtf{задание на выполнение некоторого действия}
	\scnidtf{постановка задачи}
	\scnidtf{задачная ситуация}
	\scnidtf{спецификация некоторого действия, обладающая достаточной полнотой для выполнения этого действия}
\end{SCn}

Каждая \textbf{\textit{задача}} представляет собой спецификацию действия, которое либо уже выполнено, либо выполняется в текущий момент (в настоящее время), либо планируется (должно) быть выполненным, либо может быть выполнено (но не обязательно). В зависимости от конкретного класса задач, описываться может как внутреннее состояние самой интеллектуальной системы, так и требуемое состояние внешней среды.

Классификация задач может осуществляться по дидактическому признаку в рамках каждой предметной области, например, задачи на треугольники, задачи на системы уравнений и т.п.

Каждая \textit{задача} может включать:
\begin{textitemize}
	\item факт принадлежности \textit{действия} какому-либо частному классу \textit{действий} (например,\textit{ действие. сформировать полную семантическую окрестность указываемой сущности}), в том числе состояние \textit{действия} с точки зрения жизненного цикла (инициированное, выполняемое и т.д.);
	\item описание \textit{цели*} (\textit{результата*}) \textit{действия}, если она точно известна;
	\item указание \textit{заказчика*} действия;
	\item указание \textit{исполнителя* действия} (в том числе коллективного);
	\item указание \textit{аргумента(-ов) действия\scnrolesign};
	\item указание инструмента или посредника \textit{действия};
	\item описание \textit{декомпозиции действия*};
	\item указание \textit{последовательности действий*} в рамках \textit{декомпозиции действия*}, т.е. построение процедурного плана решения задачи. Другими словами, построение плана решения представляет собой декомпозицию соответствующего \textit{действия} на систему взаимосвязанных между собой поддействий;
	\item указание области \textit{действия};
	\item указание условия инициирования \textit{действия};
	\item момент начала и завершения \textit{действия}, в том числе планируемый и фактический, предполагаемая и/или фактическая длительность выполнения.
\end{textitemize}
Некоторые задачи могут быть дополнительно уточнены контекстом -- дополнительной информацией о сущностях, рассматриваемых в формулировке \textit{задачи}, т.е. описанием того, что дано, что известно об указанных сущностях.

Кроме этого, \textit{задача} может включать любую дополнительную информацию о действии, например:
\begin{textitemize}
	\item перечень ресурсов и средств, которые предполагается использовать при решении задачи, например, список доступных исполнителей, временные сроки, объем имеющихся финансов и т.д.;
	\item ограничение области, в которой выполняется \textit{действие}, например, необходимо заменить одну \textit{sc-конструкцию} на другую по некоторому правилу, но только в пределах некоторого \textit{раздела базы знаний};
	\item ограничение знаний, которые можно использовать для решения той или иной задачи, например, необходимо решить задачу по алгебре, используя только те утверждения, которые входят в курс школьной программы до седьмого класса включительно, и не используя утверждения, изучаемые в старших классах;
	\item и прочее.
\end{textitemize}

Как и в случае с действиями, решаемыми системой, можно классифицировать \textit{информационные задачи} и \textit{поведенческие задачи}.

С другой стороны, с точки зрения формулировки поставленной задачи, можно выделить \textit{декларативные формулировки задачи} и \textit{процедурные формулировки задачи}. Следует отметить, что данные классы задач не противопоставляются друг другу, и могут существовать формулировки задач, использующие оба подхода.

\begin{SCn}
	\scnheader{задача}
	\scnsuperset{процедурная формулировка задачи}
	\scnsuperset{декларативная формулировка задачи}
	\scnsuperset{вопрос}
	\scnsuperset{команда}
	\scnsubset{знание}
	\scnsuperset{инициированная задача}
	\begin{scnindent}
		\scnidtf{формулировка задачи, которая подлежит выполнению}
	\end{scnindent}
	\scnsuperset{декларативная формулировка задачи}
	\scnsuperset{процедурная формулировка задачи}
	\scnsuperset{декларативно-процедурная формулировка задачи}
	\begin{scnindent}
		\scnidtf{задача, в формулировке которой присутствуют как декларативные (целевые), так и процедурные аспекты}
	\end{scnindent}
	\scnsuperset{задача, решаемая в памяти кибернетической системы}
	\begin{scnindent}
		\scnsuperset{задача, решаемая в памяти индивидуальной кибернетической системы}
		\scnsuperset{задача, решаемая в общей памяти многоагентной системы}
		\scnidtf{информационная задача}
		\scnidtf{задача, направленная либо на \underline{генерацию} или поиск информации, удовлетворяющей заданным требованиям, либо на некоторое \underline{преобразование} заданной информации}
		\scnsuperset{математическая задача}
	\end{scnindent}
\end{SCn}

Формулировка \textit{задачи} может не содержать указания контекста (области решения) \textit{задачи} (в этом случае областью решения \textit{задачи} считается либо вся \textit{база знаний}, либо ее согласованная часть), а также может не содержать либо описания исходной ситуации, либо описания целевой ситуации. Так, например, описание целевой ситуации для явно специфицированного противоречия, обнаруженного в \textit{базе знаний}, не требуется.

\textbf{\textit{декларативная формулировка задачи}} представляет собой описание исходной (начальной) ситуации, являющейся условием выполнения соответствующего действия, и целевой (конечной) ситуации, являющейся результатом выполнения этого действия, то есть
описание ситуации (состояния), которое должно быть достигнуто в результате выполнения планируемого действия. Другими словами, такая формулировка задачи включает явное или неявное описание:
\begin{textitemize}
	\item того, что \underline{дано}, -- исходные данные, условия выполнения специфицируемого действия;
	\item того, что \underline{требуется}, -- формулировка цели, результата выполнения указанного действия.
\end{textitemize}

В случае \textbf{\textit{процедурной формулировки задачи}} явно указывается характеристика действия, специфицируемого этой задачей, а именно, например, указывается:
\begin{textitemize}
	\item субъект или субъекты, выполняющие это действие;
	\item объекты, над которыми действие выполняется, -- аргументы действия;
	\item инструменты, с помощью которых выполняется действие;
	\item момент и, возможно, дополнительные условия начала и завершения выполнения действия;
	\item явно указывается класс или классы, которым принадлежит каждое \textit{действие} (включая поддействия).
\end{textitemize}

При этом явно не уточняется, что должно быть результатом выполнения соответствующего действия.

Заметим, что, при необходимости, \textit{процедурная формулировка задачи} может быть сведена к \textit{декларативной формулировке задачи} путем трансляции на основе некоторого правила, например, определения класса действия через более общий класс.

Частными видами задач являются \textit{вопрос} и \textit{команда}.

\begin{SCn}
	\scnheader{вопрос}
	\scnidtf{запрос}
	\scnsubset{задача, решаемая в памяти кибернетической системы}
	\scnidtf{непроцедурная формулировка задачи на поиск (в текущем состоянии базы знаний) или на генерацию знания, удовлетворяющего заданным требованиям}
	\scnsuperset{вопрос -- что это такое}
	\scnsuperset{вопрос -- почему}
	\scnsuperset{вопрос -- зачем}
	\scnsuperset{вопрос -- как}
	\begin{scnindent}
		\scnidtf{каким способом}
		\scnidtf{запрос метода (способа) решения заданного (указываемого) вида задач или класса задач либо плана решения конкретной указываемой задачи}
	\end{scnindent}
	\scnidtf{задача, направленная на удовлетворение информационной потребности некоторого субъекта-заказчика}

	\scnheader{команда}
	\scnidtf{инициированная задача}
	\scnidtf{спецификация инициированного действия}
\end{SCn}


Следует отметить, что, наряду в приведенной предельно общей классификацией задач, по сути отражающей классы задач с точки зрения их формулировки, должна существовать классификация задач с точки зрения их семантики, то есть с точки зрения сути специфицируемого действия. За основу такой классификация можно взять классификацию, представленную в работе \cite{Fayans2020}.

В рамках же данной работы, как уже было сказано, наибольший интерес представляют задачи, решаемые в sc-памяти.

\subsection{Понятие класса действий и класса задач}
\label{subsec_action_and_problem_classes}

С точки зрения организации процесса решения задач более важными являются не столько понятия \textit{действия} и \textit{задачи}, сколько понятия \textit{класса действий} и \textit{класса задач}, поскольку именно для них разрабатываются соответствующие алгоритмы выполнения и способы решения.

\textbf{\textit{Класс действий}} определим как \underline{максимальное} множество аналогичных (похожих в определенном смысле) действий, для которого существует (но не обязательно известный в текущий момент) по крайней мере один \textbf{метод} (или средство), обеспечивающий выполнение \underline{любого} действия из указанного множества действий.

\begin{SCn}
	\scnheader{класс действий}
	\scnrelto{семейство подклассов}{действие}
	\scnidtf{множество однотипных действий}
	\scnsuperset{класс элементарных действий}
	\scnsuperset{класс легковыполнимых сложных действий}
\end{SCn}

Каждому выделяемому \textit{классу действий} соответствует по крайней мере один общий для них \textit{метод} выполнения этих \textit{действий}. Это означает то, что речь идет о \underline{семантической} "кластеризации"{} множества \textit{действий}, т.е. о выделении \textit{классов действий} по признаку \underline{семантической близости} (сходства) \textit{действий}, входящих в состав выделяемого \textit{класса действий}. При этом прежде всего учитывается аналогичность (сходство) \textit{исходных ситуаций} и \textit{целевых ситуаций} рассматриваемых \textit{действий}, т.е. аналогичность \textit{задач}, решаемых в результате выполнения соответствующих \textit{действий}. Поскольку одна и та же \textit{задача} может быть решена в результате выполнения нескольких \underline{разных} \textit{действий}, принадлежащих \underline{разным} \textit{классам действий}, следует говорить не только о \textit{классах действий} (множествах аналогичных действий), но и о \textbf{\textit{классах задач}} (о множествах аналогичных задач), решаемых этими \textit{действиями}. Так, например, на множестве \textit{классов действий} заданы следующие \textit{отношения}:
\begin{textitemize}
	\item \textit{отношение}, каждая связка которого связывает два разных (непересекающихся) \textit{класса действий}, осуществляющих решение одного и того же \textit{класса задач};
	\item \textit{отношение}, каждая связка которого связывает два разных \textit{класса действий}, осуществляющих решение разных \textit{классов задач}, один из которых является \textit{надмножеством} другого.
\end{textitemize}

Кроме класса действий также выделяется понятие \textbf{\textit{класса элементарных действий}}, то есть множества элементарных действий, указание принадлежности которому является \underline{необходимым} и достаточным условием для выполнения этого действия. Множество всевозможных элементарных действий, выполняемых каждым субъектом, должно быть \underline{разбито} на классы элементарных действий.

Принадлежность некоторого \textit{класса действий} множеству \textbf{\textit{класс элементарных действий}} фиксирует факт того, что при указании всех необходимых аргументов принадлежности \textit{действия} данному классу достаточно для того, чтобы некоторый субъект мог приступить к выполнению этого действия.

При этом, даже если \textit{класс действий} принадлежит множеству \textbf{\textit{класс элементарных действий}}, не запрещается вводить более частные \textit{классы действий}, для которых, например, заранее фиксируется один из аргументов.

Если конкретный \textbf{\textit{класс элементарных действий}} является более частным по отношению к \textit{действиям в sc-памяти}, то это говорит о наличии в текущей версии системы как минимум одного \textit{sc-агента}, ориентированного на выполнение действий данного класса.

Кроме того, целесообразно также ввести понятие \textit{класса легковыполнимых сложных действий}, то есть множества \textit{сложных действий}, для которых известен и доступен по крайней мере один \textbf{\textit{метод}}, интерпретация которого позволяет осуществить полную (окончательную, завершающуюся элементарными действиями) декомпозицию на поддействия \underline{каждого} сложного действия из указанного выше множества.

Принадлежность некоторого \textit{класса действий} множеству \textbf{\textit{класс легковыполнимых сложных действий}} фиксирует факт того, что даже при указании всех необходимых аргументов принадлежности \textit{действия} данному классу недостаточно для того, чтобы некоторый \textit{субъект} приступил к выполнению этого действия, и требуются дополнительные уточнения.

В свою очередь, под \textbf{\textit{классом задач}} будем понимать множество задач, для которого можно построить обобщенную формулировку задач, соответствующую всему этому множеству задач. Каждая \textit{обобщенная формулировка задач соответствующего класса}, по сути, есть не что иное, как строгое логическое определение указанного класса задач.

\begin{SCn}
	\scnheader{класс задач}
	\scnrelto{семейство подмножеств}{задача}
\end{SCn}

Конкретный класс действий может быть определен как минимум двумя способами.

\begin{SCn}
	\scnheader{класс действий}

	\begin{scnsubdividing}
		\scnitem{\textbf{класс действий, однозначно задаваемый решаемым классом задач}}
		\begin{scnindent}
			\scnidtf{\textit{класс действий}, обеспечивающих решение соответствующего \textit{класса задач} и использующих при этом любые, самые разные \textit{методы} решения задач этого класса}
		\end{scnindent}
		\scnitem{\textbf{класс действий, однозначно задаваемый используемым методом решения задач}}
	\end{scnsubdividing}
\end{SCn}

Далее более подробно рассмотрим формальную трактовку понятия \textit{метода}.

\subsection{Понятие метода}
\label{subsec_method_concept}

Под методом будем понимать описание того, \underline{как} может быть выполнено любое или почти любое (с явным указанием исключений) действие, принадлежащее соответствующему классу действий.

Формально, \textit{метод} -- это спецификация решения задачи какого-то класса \cite{Standard2021}, \cite{Tuzov1986}. В состав спецификации каждого класса задач входит описание способа \scnqq{привязки} метода к исходным данным конкретной задачи, решаемой с помощью этого метода.

\begin{SCn}
	\scnheader{метод}
	\scnidtf{метод решения соответствующего класса задач, обеспечивающий решение любой или большинства задач указанного класса}
	\scnidtf{обобщенная спецификация выполнения действий соответствующего класса}
	\scnidtf{обобщенная спецификация решения задач соответствующего класса}
	\scnidtf{программа решения задач соответствующего класса, которая может быть как процедурной, так и декларативной (непроцедурной)}
	\scnidtf{знание о том, как можно решать задачи соответствующего класса}
	\scnsubset{знание}
	\scniselement{вид знаний}
	\scnidtf{способ}
	\scnidtf{знание о том, как надо решать задачи соответствующего класса задач (множества эквивалентных (однотипных, похожих) задач)}
	\scnidtf{метод (способ) решения некоторого (соответствующего) класса задач}
	\scnidtf{информация (знание), достаточная для того, чтобы решить любую \textit{задачу}, принадлежащую соответствующему \textit{классу задач}, с помощью соответствующей \textit{модели решения задач}}
\end{SCn}

В состав спецификации каждого \textit{класса задач} входит описание способа "привязки"{} \textit{метода} к исходным данным конкретной \textit{задачи}, решаемой с помощью этого \textit{метода}. Описание такого способа "привязки"{} включает в себя:
\begin{textitemize}
	\item набор переменных, которые входят как в состав \textit{метода}, так и в состав \textit{обобщенной формулировки задач соответствующего класса}, и значениями которых являются соответствующие элементы исходных данных каждой конкретной решаемой задачи;
	\item часть \textit{обобщенной формулировки задач} того класса, которому соответствует рассматриваемый \textit{метод}, являющихся описанием \underline{условия применения} этого \textit{метода}.
\end{textitemize}

Сама рассматриваемая "привязка"{} \textit{метода} к конкретной \textit{задаче}, решаемой с помощью этого \textit{метода}, осуществляется путем \underline{поиска} в \textit{базе знаний} такого фрагмента, который удовлетворяет условиям применения указанного \textit{метода}. Одним из результатов такого поиска и является установление соответствия между указанными выше переменными используемого \textit{метода} и значениями этих переменных в рамках конкретной решаемой \textit{задачи}.

Другим вариантом установления рассматриваемого соответствия является явное обращение (вызов, call) соответствующего \textit{метода} (программы) с явной передачей соответствующих параметров. Но такое не всегда возможно, т.к. при выполнении процесса решения конкретной \textit{задачи} на основе декларативной спецификации выполнения этого действия нет возможности установить:
\begin{textitemize}
	\item когда необходимо инициировать вызов (использование) требуемого \textit{метода};
	\item какой конкретно \textit{метод} необходимо использовать;
	\item какие параметры, соответствующие конкретной инициируемой \textit{задаче}, необходимо передать для "привязки"{} используемого \textit{метода} к этой \textit{задаче}.
\end{textitemize}

Процесс "привязки"{} \textit{метода} решения \textit{задач} к конкретной \textit{задаче}, решаемой с помощью этого \textit{метода}, можно также представить как процесс, состоящий из следующих этапов:
\begin{textitemize}
	\item построение копии используемого \textit{метода};
	\item склеивание основных (ключевых) переменных используемого \textit{метода} с основными параметрами конкретной решаемой \textit{задачи}.
\end{textitemize}

В результате этого, на основе рассматриваемого \textit{метода}, используемого в качестве образца (шаблона), строится спецификация процесса решения конкретной задачи -- процедурная спецификация (\textit{план}) или декларативная.

Заметим, что \textit{методы} могут использоваться даже при построении \textit{планов} решения конкретных \textit{задач} в случае, когда возникает необходимость многократного повторения неких цепочек \textit{действий} при априори неизвестном количестве таких повторений. Речь идет о различного вида \textbf{циклах}, которые являются простейшим видом процедурных \textit{методов} решения задач, многократно используемых (повторяемых) при реализации \textit{планов} решения некоторых \textit{задач}.

Очевидно также, что одному \textit{классу действий} может соответствовать несколько \textit{методов}.

Термин ``метод'', таким образом, будем считать синонимичным термину ``программа'' в обобщенном понимании этого термина.

\begin{SCn}
	\scnheader{метод}
	\scnidtf{программа}
	\scnidtf{программа выполнения действий некоторого класса}
	\scnsuperset{процедурная программа}
	\begin{scnindent}
		\scnidtf{обобщенный план}
		\scnidtf{обобщенный план выполнения некоторого класса действий}
		\scnidtf{обобщенный план решения некоторого класса задач}
		\scnidtf{обобщенная спецификация декомпозиции любого действия, принадлежащего заданному классу действий}
		\scnsubset{алгоритм}
	\end{scnindent}
\end{SCn}

Рассмотрим более подробно понятие процедурной программы (процедурного метода). Каждая \textbf{\textit{процедурная программа}} представляет собой обобщенный план выполнения \textit{действий}, принадлежащих некоторому классу, то есть \textit{семантическую окрестность; ключевым sc-элементом\scnrolesign} является \textit{класс действий}, для элементов которого дополнительно детализируется процесс их выполнения.

Входным параметрам \textit{процедурной программы} в традиционном понимании соответствуют аргументы, соответствующие каждому \textit{действию} из \textit{класса действий}, описываемого данной {\textit{процедурной программой}. При генерации на основе данной программы \textit{плана} выполнения конкретного \textit{действия} из данного класса эти аргументы принимают конкретные значения.

Каждая \textit{процедурная программа} представляет собой систему описанных действий с дополнительным указанием для действия:
\begin{textitemize}
	\item либо \textit{последовательности выполнения действий*} (передачи инициирования), когда условием выполнения (инициирования) действий является завершение выполнения одного из указанных или всех указанных действий;
	\item либо события в базе знаний или внешней среде, являющегося условием его инициирования;
	\item либо ситуации в базе знаний или внешней среде, являющейся условием его инициирования.
\end{textitemize}
}

Понятие метода позволяет определить отношение \textit{эквивалентность задач*} на множестве задач. Задачи являются эквивалентными в том и только в том случае, если они могут быть решены путем интерпретации одного и того же \textit{метода} (способа), хранимого в памяти кибернетической системы.
Некоторые \textit{задачи} могут быть решены разными \textit{методами}, один из которых, например, является обобщением другого. Таким образом, на множестве методов можно также задать ряд отношений.

Отметим, что понятие \textit{метода} фактически позволяет локализовать область решения задач соответствующего класса, то есть ограничить множество знаний, которых достаточно для решения задач данного класса определенным способом. Это, в свою очередь, позволяет повысить эффективность работы системы в целом, исключая число лишних действий.

\begin{SCn}
	\scnheader{отношение, заданное на множестве методов}
	\scnhaselement{подметод*}
	\begin{scnindent}
		\scnidtf{подпрограмма*}
		\scnidtf{быть методом, использование которого (обращение к которому) предполагается при реализации заданного метода*}
		\scnrelboth{следует отличать}{частный метод*}
		\begin{scnindent}
			\scnidtf{быть методом, обеспечивающим решение класса задач, который является подклассом задач, решаемых с помощью заданного метода*}
		\end{scnindent}
	\end{scnindent}
\end{SCn}

В литературе, посвященной построению решателей задач, встречается понятие \textbf{\textit{стратегии решения задач}}. Определим его как метаметод решения задач, обеспечивающий либо поиск одного релевантного известного метода, либо синтез целенаправленной последовательности акций применения в общем случае различных известных методов.

\begin{SCn}
	\scnheader{стратегия решения задач}
	\scnsubset{метод}
\end{SCn}

Можно говорить об универсальном метаметоде (универсальной стратегии) решения задач, объясняющем всевозможные частные стратегии.
В частности, можно говорить о нескольких глобальных \textit{стратегиях решения информационных задач} в базах знаний. Пусть в базе знаний появился знак инициированного действия с формулировкой, соответствующей информационной цели, т.е. цели, направленной только на изменение состояния базы знаний. И пусть текущее состояние базы знаний не содержит контекст (исходные данные), достаточный для достижения указанной выше цели, т.е. такой контекст, для которого в доступном пакете (наборе) методов (программ) имеется метод (программа), использование которого позволяет достичь указанной выше цели. Для достижения такой цели, контекст (исходные данные) которой недостаточен, существует три подхода (три стратегии):
\begin{textitemize}
	\item декомпозиция (сведение изначальной цели к иерархической системе и/или подцелей (и/или подзадач) на основе анализа текущего состояния базы знаний и анализа того, чего не хватает в базе знаний для использования того или иного метода).

	При этом наибольшее внимание уделяется методам, для создания условий использования которых требуется меньше усилий. В конечном счете мы должны дойти (на самом нижнем уровне иерархии) до подцелей, контекст которых достаточен для применения одного из имеющихся методов (программ) решения задач;
	\item генерация новых знаний в семантической окрестности формулировки изначальной цели с помощью \underline{любых} доступных методов в надежде получить такое состояние базы знаний, которое будет содержать нужный контекст (достаточные исходные данные) для достижения изначальной цели с помощью какого-либо имеющегося метода решения задач;
	\item комбинация первого и второго подходов.
\end{textitemize}
Аналогичные стратегии существуют и для поиска пути решения задач, решаемых во внешней среде.

\subsection{Спецификация методов и понятие навыка}
\label{subsec_skill_concept}

Каждый конкретный \textit{метод} рассматривается нами не только как важный вид спецификации соответствующего класса задач, но также и как объект, который и сам нуждается в спецификации, обеспечивающей непосредственное применение этого метода. Другими словами, метод является не только спецификацией (спецификацией соответствующего класса задач), но и \underline{объектом} спецификации. Важнейшим видом такой спецификации является указание \textit{операционной семантики метода}.

\begin{SCn}
	\scnheader{операционная семантика метода*}
	\scnsubset{спецификация*}
	\scnidtf{семейство методов, обеспечивающих интерпретацию заданного метода*}
	\scnidtf{формальное описание интерпретатора заданного метода*}
	\scnrelfrom{второй домен}{\textbf{операционная семантика метода}}
	\begin{scnindent}
		\scnsuperset{\textbf{полное представление операционной семантики метода}}
		\begin{scnindent}
			\scnidtf{представление \textit{операционной семантики метода}, доведенное (детализированное) до уровня всех \textit{спецификаций элементарных действий}, выполняемых в процессе интерпретации соответствующего \textit{метода}}
		\end{scnindent}
	\end{scnindent}

	\scnheader{декларативная семантика метода*}
	\scnsubset{спецификация*}
	\scnidtf{описание системы понятий, которые используются в рамках данного метода*}
\end{SCn}

Отношение \textit{декларативная семантика метода*} связывает \textit{метод} и формальное описание системы понятий (фрагмент \textit{логической онтологии} соответствующей \textit{предметной области}), которые используются (упоминаются) в рамках данного метода. Это необходимо для того, чтобы гарантировать однозначность трактовки одного и того же понятия в рамках метода и остальной части базы знаний, что особенно актуально при заимствовании метода из библиотеки многократно используемых компонентов решателей задач. Важно отметить, что тот факт, что какие-либо понятия используются в рамках метода, не означает, что формальная запись их определений является частью данного метода. Например, в состав метода, позволяющего решать задачи на вычисление площади треугольника, будут входить различные формулы расчета площади треугольника, но не будут входить сами определения понятий ``площадь'', ``треугольник'' и т.д., поскольку при наличии априори верных формул эти определения не будут непосредственно использоваться в процессе решения задачи. В то же время формальные определения указанных понятий будут входить в состав декларативной семантики данного метода.

Объединение \textit{метода} и его операционной семантики, то есть информации о том, каким образом должен интерпретироваться данный \textit{метод}, будем называть \textbf{\textit{навыком}}.

\begin{SCn}
	\scnheader{навык}
	\scnidtf{умение}
	\scnidtf{объединение \textit{метода} с его исчерпывающей спецификацией -- \textit{полным представлением операционной семантики метода}}
	\scnidtf{метод, интерпретация (выполнение, использование) которого полностью может быть осуществлено данной кибернетической системой, в памяти которой хранится указанный метод}
	\scnidtf{метод, который данная кибернетическая система умеет (может) применять}
	\scnidtf{метод + метод его интерпретации}
	\scnidtf{умение решать соответствующий класс эквивалентных задач}
	\scnidtf{метод плюс его операционная семантика, описывающая то, как интерпретируется (выполняется, реализуется) этот метод, и являющаяся одновременно операционной семантикой соответствующей модели решения задач}

	\begin{scnsubdividing}
		\scnitem{активный навык}
		\begin{scnindent}
			\scnidtf{самоинициирующийся навык}
		\end{scnindent}
		\scnitem{пассивный навык}
	\end{scnsubdividing}
\end{SCn}

Таким образом, понятие \textit{навыка} является важнейшим понятием с точки зрения построения решателей задач, поскольку объединяет в себе не только декларативную часть описания способа решения класса задач, но и операционную.

\textit{Навыки} могут быть \textit{пассивными навыками}, то есть такими \textit{навыками}, применение которых должно явно инициироваться каким-либо агентом, либо \textit{активными навыками}, которые инициируются самостоятельно при возникновении соответствующей ситуации в базе знаний. Для этого в состав \textit{активного навыка}, помимо \textit{метода} и его операционной семантики, включается также \textit{sc-агент}, который реагирует на появление соответствующей ситуации в базе знаний и инициирует интерпретацию \textit{метода} данного \textit{навыка}.
Такое разделение позволяет реализовывать и комбинировать различные подходы к решению задач, в частности, \textit{пассивные навыки} можно рассматривать в качестве способа реализации концепции интеллектуального пакета программ.

\subsection{Понятие класса методов и языка представления методов}
\label{subsec_method_lang_concept}

Как действия и задачи, методы могут быть классифицированы по различным классам. Будем называть \textbf{\textit{классом методов}} множество методов, для которых можно \underline{унифицировать} представление (спецификацию) этих методов.

\begin{SCn}
	\scnheader{класс методов}
	\scnrelto{семейство подклассов}{метод}
	\scnidtf{множество методов, для которых можно унифицировать представление (спецификацию) этих методов}
	\scnidtf{множество всевозможных методов решения задач, имеющих общий язык представления этих методов}
	\scnidtf{множество методов, для которых задан язык представления этих методов}

	\scnhaselement{процедурный метод решения задач}
	\begin{scnindent}
		\scnsuperset{алгоритмический метод решения задач}
	\end{scnindent}
	\scnhaselement{непроцедурный метод решения задач}
	\begin{scnindent}
		\scnsuperset{логический метод решения задач}
		\begin{scnindent}
			\scnsuperset{продукционный метод решения задач}
			\scnsuperset{функциональный метод решения задач}
		\end{scnindent}
		\scnsuperset{продукционный метод решения задач}
		\scnsuperset{функциональный метод решения задач}
		\begin{scnindent}
			\scnsuperset{искусственная нейронная сеть}
			\begin{scnindent}
				\scnidtf{класс методов решения задач на основе искусственных нейронных сетей}
			\end{scnindent}
			\scnsuperset{генетический \scnqq{алгоритм}}
		\end{scnindent}
	\end{scnindent}

	\scnidtf{множество методов, основанных на общей онтологии}
	\scnidtf{множество методов, представленных на одинаковом языке}
	\scnidtf{множество методов решений задач, которому соответствует специальный язык (например, sc-язык), обеспечивающий представление методов из этого множества}
	\scnidtf{множество методов, которому ставится в соответствие отдельная модель решения задач}
\end{SCn}

Каждому конкретному \textit{классу методов} взаимно однозначно соответствует \textit{язык представления методов}, принадлежащих этому (специфицируемому) \textit{классу методов}. Таким образом, спецификация каждого \textit{класса методов} сводится к спецификации соответствующего \textit{языка представления методов}, т.е. к описанию его синтаксической, денотационной и операционной семантики. Примерами \textit{языков представления методов} являются все \textit{языки программирования}, которые, в основном, относятся к подклассу \textit{языков представления методов} -- к \textit{языкам представления методов обработки информации}. Но сейчас все большую актуальность приобретает необходимость создания эффективных формальных языков представления методов выполнения действий во внешней среде кибернетических систем. Без этого комплексная автоматизация \scncite{Pospelov2021}, в частности, в промышленной сфере, невозможна.

Таких специализированных языков может быть выделено целое множество, каждому из которых будет соответствовать своя модель решения задач (т.е. свой интерпретатор).

Под \textit{языком представления методов} будем подразумевать формальный язык, (1) знаковыми конструкциями которого являются соответствующие методы, для которых существуют общие правила построения и (2) общие правила соотнесения с теми сущностями и связями между ними, которые описываются этими методами.

\begin{SCn}
	\scnheader{язык представления методов}
	\scnidtf{язык методов}
	\scnidtf{язык представления методов, соответствующих определенному классу методов}
	\scnidtf{язык (например, sc-язык) представления методов соответствующего класса методов}
	\scnsubset{язык}
	\scnsubset{формальный язык}
	\scnidtf{формальный язык, (1) знаковыми конструкциями которого являются соответствующие методы, для которых существуют общие правила построения и (2) общие правила соотнесения с теми сущностями и связями между ними, которые описываются этими методами}
	\scnidtf{язык программирования}
	\scnsuperset{язык представления методов обработки информации}
	\begin{scnindent}
		\scnidtf{язык программирования внутренних действий кибернетической системы, выполняемых в их памяти}
		\scnidtf{язык представления методов решения задач в памяти кибернетических систем}
	\end{scnindent}
	\scnsuperset{язык представления методов решения задач во внешней среде кибернетических систем}
	\begin{scnindent}
		\scnidtf{язык программирования внешних действий кибернетических систем}
	\end{scnindent}
\end{SCn}

Метод принадлежит языку представления методов, если он является синтаксически корректным, синтаксически целостным, семантически корректным и семантически целостным методом заданного языка представления методов (!).

\begin{SCn}
	\scnheader{отношение, заданное на множестве языков представления методов\scnsupergroupsign}
	\scnidtf{отношение, область определения которого включает в себя множество всевозможных языков представления методов}
	\scnhaselement{метод заданного языка представления методов*}
	\scnhaselement{синтаксически корректный метод для заданного языка представления методов*}
	\begin{scnindent}
		\scnidtf{метод, не содержащий синтаксических ошибок для заданного языка представления методов*}
		\scnsubset{синтаксически корректная знаковая конструкция для заданного языка*}
	\end{scnindent}
	\scnhaselement{синтаксически целостный метод для заданного языка представления методов*}
	\begin{scnindent}
		\scnsubset{синтаксически целостная знаковая конструкция для заданного языка*}
	\end{scnindent}
	\scnhaselement{семантически корректный метод для заданного языка представления методов*}
	\begin{scnindent}
		\scnidtf{метод, не содержащий семантических ошибок для заданного языка представления методов*}
		\scnsubset{семантически корректная знаковая конструкция для заданного языка*}
	\end{scnindent}
	\scnhaselement{семантически целостный метод для заданного языка представления методов*}
	\begin{scnindent}
		\scnsubset{семантически целостная знаковая конструкция для заданного языка*}
		\scnidtf{метод заданного языка представления методов, содержащий достаточную информацию для установления его
		истинности*}
	\end{scnindent}
\end{SCn}

\begin{SCn}
	\scnheader{метод заданного языка представления методов*}
	\scnidtf{метод, принадлежащий заданному языку программирования*}
	\scnsubset{текст заданного языка*}
	\scnrelfrom{второй домен}{метод}
	\begin{scnreltoset}{объединение}
		\scnitem{\scnnonamednode}
		\begin{scnindent}
			\begin{scnreltoset}{объединение}
				\scnitem{синтаксически корректный метод для заданного языка представления методов*}
				\scnitem{синтаксически целостный метод для заданного языка представления методов*}
			\end{scnreltoset}
		\end{scnindent}
		\scnitem{\scnnonamednode}
		\begin{scnindent}
			\begin{scnreltoset}{объединение}
				\scnitem{семантически корректный метод для заданного языка представления методов*}
				\scnitem{синтаксически целостный метод для заданного языка представления методов*}
			\end{scnreltoset}
		\end{scnindent}
	\end{scnreltoset}
\end{SCn}

\subsection{Общая классификация языков представления методов}
\label{subsec_method_lang_classes}

Языки представления методов в современном информационном обществе различают по их парадигмам: \textit{процедурные}, \textit{функциональные}, \textit{логические}, \textit{объектно-ориентированные} и т. д. Таким, например, в методах процедурного я.п.м. решение задачи компьютером формируется в виде последовательности операторов, в методах функционального я.п.м. — указанием других методов. В логическом я.п.м. применяются высказывания, а в объектно-ориентированном — объекты.

\begin{SCn}
	\scnheader{язык представления методов}
	\scnsuperset{язык представления методов общего назначения}
	\begin{scnindent}
		\scnidtf{язык программирования общего назначения}
	\end{scnindent}
	\scnsuperset{предметно-ориентированный язык представления методов}
	\begin{scnindent}
		\scnidtf{предметно-ориентированный язык программирования}
	\end{scnindent}
	\scnrelfrom{разбиение}{парадигма языка представления методов\scnsupergroupsign}
	\begin{scnindent}
		\begin{scneqtoset}
			\scnitem{процедурный язык представления методов}
			\scnitem{непроцедурный язык представления методов}
		\end{scneqtoset}
	\end{scnindent}
\end{SCn}

\textit{Процедурные языки представления методов} задают вычисления как последовательность операторов (команд).
Они ориентированы на компьютеры с архитектурой фон Неймана. Основные понятия процедурных я.п.м. тесно связаны с компонентами компьютера:
\begin{textitemize}
	\item переменными различных типов, которые моделируют ячейки памяти компьютера;
	\item операторами присваивания, которые моделируют пересылки данных между участками памяти;
	\item повторений действий в форме итерации, которые моделируют хранение информации в смежных ячейках памяти;
	\item и другое.
\end{textitemize}

\begin{SCn}
	\scnheader{процедурный язык представления методов}
	\scnidtf{императивный язык представления методов}
	\scnsuperset{структурный язык представления методов}
	\begin{scnindent}
		\begin{scnhaselementrolelist}{пример}
			\scnitem{Fortran}
			\scnitem{Си}
			\scnitem{Pascal}
		\end{scnhaselementrolelist}
	\end{scnindent}
	\scnsuperset{объектно-ориентированный язык представления методов}
	\begin{scnindent}
		\begin{scnhaselementrolelist}{пример}
			\scnitem{Java}
			\scnitem{Smalltalk}
			\scnitem{HTML}
		\end{scnhaselementrolelist}
		\scnsuperset{аспектно-ориентированный язык представления методов}
	\end{scnindent}
	\scnsuperset{скриптовый язык представления методов}
	\begin{scnindent}
		\scnidtf{склеивающий язык представления методов}
	\end{scnindent}
\end{SCn}

\textit{Непроцедурные языки представления методов}, в отличие от процедурных, задают вычисления как последовательность связанных между собой объектов. Основные понятия непроцедурных я.п.м. обычно не связаны с компонентами компьютера.

\begin{SCn}
	\scnheader{непроцедурный язык представления методов}
	\scnidtf{декларативный язык представления методов}
	\scnsuperset{логический язык представления методов}
	\begin{scnindent}
		\begin{scnhaselementrolelist}{пример}
			\scnitem{Prolog}
		\end{scnhaselementrolelist}
	\end{scnindent}
	\scnsuperset{продукционный язык представления методов}
	\scnsuperset{функциональный язык представления методов}
	\begin{scnindent}
		\scnidtf{аппликативный язык представления методов}
		\begin{scnhaselementrolelist}{пример}
			\scnitem{LISP}
		\end{scnhaselementrolelist}
	\end{scnindent}
\end{SCn}

\subsection{Понятие модели решения задач}
\label{sec_problem_solving_model}

По аналогии с понятием стратегии решения задач введем понятие \textbf{\textit{модели решения задач}}, которое будем трактовать как метаметод интерпретации соответствующего класса методов.

\begin{SCn}
	\scnheader{модель решения задач}
	\scnsubset{метод}
	\scnidtf{метаметод}
	\scnidtf{абстрактная машина интерпретации соответствующего класса методов}
	\scnidtf{иерархическая система "микропрограмм"{}, обеспечивающих интерпретацию соответствующего класса методов}
	\scnsuperset{алгоритмическая модель решения задач}
	\scnsuperset{процедурная параллельная синхронная модель решения задач}
	\scnsuperset{процедурная параллельная асинхронная модель решения задач}
	\scnsuperset{продукционная модель решения задач}
	\scnsuperset{функциональная модель решения задач}
	\scnsuperset{логическая модель решения задач}
	\begin{scnindent}
		\scnsuperset{четкая логическая модель решения задач}
		\scnsuperset{нечеткая логическая модель решения задач}
	\end{scnindent}
	\scnsuperset{"нейросетевая"{} модель решения задач}
	\scnsuperset{"генетическая"{} модель решения задач}
\end{SCn}

Каждая \textit{модель решения задач} задается:
\begin{textitemize}
	\item соответствующим классом методов решения задач, т.е. языком представления методов этого класса;
	\item предметной областью этого класса методов;
	\item онтологией этого класса методов (т.е. денотационной семантикой языка представления этих методов);
	\item операционной семантикой указанного класса методов.
\end{textitemize}

Важно отметить, что для интерпретации \underline{всех} моделей решения задач может быть использован агентно-ориентированный подход, рассмотренный в работе \cite{Shunkevich2018}.

\begin{SCn}
	\scnheader{спецификация*}
	\scnsuperset{\textbf{модель решения задач}*}
	\begin{scnindent}
		\scneq{сужение отношения по первому домену (спецификация*; класс методов)*}
		\scnidtf{спецификация \textit{класса методов}*}
		\scnidtf{спецификация \textit{языка представления методов}*}
		\begin{scnsubdividing}
			\scnitem{\textbf{синтаксис языка представления методов соответствующего класса}*}
			\scnitem{\textbf{денотационная семантика языка представления методов соответствующего класса}*}
			\scnitem{\textbf{операционная семантика языка представления методов соответствующего класса}*}
		\end{scnsubdividing}
	\end{scnindent}
\end{SCn}

Модель решения задач ставит в соответствие некоторому классу методов синтаксис, денотационную и операционную семантику языка представления методов соответствующего класса.

\begin{SCn}
	\scnheader{денотационная семантика языка представления методов соответствующего класса}
	\scnidtf{онтология соответствующего класса методов}
	\scnidtf{денотационная семантика соответствующего класса методов}
	\scnidtf{денотационная семантика языка (sc-языка), обеспечивающего представление методов соответствующего класса}
	\scnidtf{денотационная семантика соответствующей модели решения задач}
	\scnnote{Если речь идет о языке, обеспечивающем внутреннее представление методов соответствующего класса в ostis-системе, то синтаксис этого языка совпадает с синтаксисом sc-кода}
	\scnsubset{онтология}

	\scnheader{операционная семантика языка представления методов соответствующего класса}
	\scnidtf{метаметод интерпретации соответствующего класса методов}
	\scnidtf{семейство агентов, обеспечивающих интерпретацию (использование) любого метода, принадлежащего соответствующему классу методов}
	\scnidtf{операционная семантика соответствующей модели решения задач}
\end{SCn}

Поскольку каждому \textit{методу} соответствует \textit{обобщенная формулировка задач}, решаемых с помощью этого \textit{метода}, то каждому \textit{классу методов} должен соответствовать не только определенный \textit{язык представления методов}, принадлежащих указанному \textit{классу методов}, но и определенный \textit{язык представления обобщенных формулировок задач для различных классов задач}, решаемых с помощью \textit{методов}, принадлежащих указанному \textit{классу методов}.


\section{Локальные предметные области и онтологии действий}
\label{sec_local_sd_actions}

\section*{Заключение к Главе \ref{chapter_actions}}

Дальнейшее развитие представленных в данной главе онтологий предполагает формализацию классификации задач, решаемых интеллектуальными системами, унификацию описания задач и классов задач, описания целей, хода и результата решения задачи, методов решения задач, связей между классами задач и методами решения задач данного класса.
Это позволит обеспечить возможность глубокой интеграции всевозможных моделей решения задач различных классов и возможность облегчить процесс интеграции новых моделей решения задач в интеллектуальную систему, а также положит основу для решения ряда проблем в области разработки гибридных решателей задач, рассмотренных в \textit{Главе \ref{chapter_situation_management} \nameref{chapter_situation_management}}.

%\input{author/references}